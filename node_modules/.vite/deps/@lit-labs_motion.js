import {
  isSingleExpression
} from "./chunk-CJ3JBZQ4.js";
import {
  Directive,
  PartType,
  directive
} from "./chunk-G5XPUXFD.js";
import {
  nothing
} from "./chunk-5CB4VU4N.js";

// node_modules/lit-html/development/async-directive.js
var DEV_MODE = true;
var notifyChildrenConnectedChanged = (parent, isConnected) => {
  var _a;
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    (_a = obj["_$notifyDirectiveConnectionChanged"]) == null ? void 0 : _a.call(obj, isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
var removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while ((children == null ? void 0 : children.size) === 0);
};
var addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i = fromPartIndex; i < value.length; i++) {
        notifyChildrenConnectedChanged(value[i], false);
        removeDisconnectableFromParent(value[i]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
var installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ?? (obj._$notifyConnectionChanged = notifyChildPartConnectedChanged);
    obj._$reparentDisconnectables ?? (obj._$reparentDisconnectables = reparentDisconnectables);
  }
};
var AsyncDirective = class extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    var _a, _b;
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        (_a = this.reconnected) == null ? void 0 : _a.call(this);
      } else {
        (_b = this.disconnected) == null ? void 0 : _b.call(this);
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (DEV_MODE && this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/@lit-labs/motion/development/animate-controller.js
var controllerMap = /* @__PURE__ */ new WeakMap();
var AnimateController = class {
  constructor(host, options) {
    this.startPaused = false;
    this.disabled = false;
    this.clients = /* @__PURE__ */ new Set();
    this.pendingComplete = false;
    this.host = host;
    this.defaultOptions = options.defaultOptions || {};
    this.startPaused = !!options.startPaused;
    this.disabled = !!options.disabled;
    this.onComplete = options.onComplete;
    controllerMap.set(this.host, this);
  }
  async add(animate2) {
    var _a, _b;
    this.clients.add(animate2);
    if (this.startPaused) {
      (_a = animate2.webAnimation) == null ? void 0 : _a.pause();
    }
    this.pendingComplete = true;
    await animate2.finished;
    if (this.pendingComplete && !this.isAnimating) {
      this.pendingComplete = false;
      (_b = this.onComplete) == null ? void 0 : _b.call(this);
    }
  }
  remove(animate2) {
    this.clients.delete(animate2);
  }
  /**
   * Pauses all animations running in the host component.
   */
  pause() {
    this.clients.forEach((f) => {
      var _a;
      return (_a = f.webAnimation) == null ? void 0 : _a.pause();
    });
  }
  /**
   * Plays all active animations in the host component.
   */
  play() {
    this.clients.forEach((f) => {
      var _a;
      return (_a = f.webAnimation) == null ? void 0 : _a.play();
    });
  }
  cancel() {
    this.clients.forEach((f) => {
      var _a;
      return (_a = f.webAnimation) == null ? void 0 : _a.cancel();
    });
    this.clients.clear();
  }
  finish() {
    this.clients.forEach((f) => {
      var _a;
      return (_a = f.webAnimation) == null ? void 0 : _a.finish();
    });
    this.clients.clear();
  }
  /**
   * Toggles the play/pause state of all active `animate()` animations in the host component.
   */
  togglePlay() {
    if (this.isPlaying) {
      this.pause();
    } else {
      this.play();
    }
  }
  /**
   * Returns true if the host component has any active `animate()` animations.
   */
  get isAnimating() {
    return this.clients.size > 0;
  }
  /**
   * Returns true if the host component has any playing `animate()` animations.
   */
  get isPlaying() {
    return Array.from(this.clients).some((a) => {
      var _a;
      return ((_a = a.webAnimation) == null ? void 0 : _a.playState) === "running";
    });
  }
  async finished() {
    await Promise.all(Array.from(this.clients).map((f) => f.finished));
  }
};

// node_modules/@lit-labs/motion/development/animate.js
var z = 0;
var disconnectedProps = /* @__PURE__ */ new Map();
var renderedHosts = /* @__PURE__ */ new WeakSet();
var animationFrame = () => new Promise((resolve) => requestAnimationFrame(resolve));
var flyBelow = [{ transform: "translateY(100%) scale(0)", opacity: 0 }];
var flyAbove = [{ transform: "translateY(-100%) scale(0)", opacity: 0 }];
var flyLeft = [{ transform: "translateX(-100%) scale(0)", opacity: 0 }];
var flyRight = [{ transform: "translateX(100%) scale(0)", opacity: 0 }];
var none = [{}];
var fadeOut = [{ opacity: 0 }];
var fade = fadeOut;
var fadeIn = [{ opacity: 0 }, { opacity: 1 }];
var fadeInSlow = [
  { opacity: 0 },
  { opacity: 0.25, offset: 0.75 },
  { opacity: 1 }
];
var diffOp = (a, b) => {
  const v = a - b;
  return v === 0 ? void 0 : v;
};
var quotientOp = (a, b) => {
  const v = a / b;
  return v === 1 ? void 0 : v;
};
var transformProps = {
  left: (a, b) => {
    const value = diffOp(a, b);
    const transform = value == null || isNaN(value) ? void 0 : `translateX(${value}px)`;
    return { value, transform };
  },
  top: (a, b) => {
    const value = diffOp(a, b);
    const transform = value == null || isNaN(value) ? void 0 : `translateY(${value}px)`;
    return { value, transform };
  },
  width: (a, b) => {
    let override = void 0;
    if (b === 0) {
      b = 1;
      override = { width: "1px" };
    }
    const value = quotientOp(a, b);
    const transform = value == null || isNaN(value) ? void 0 : `scaleX(${value})`;
    return { value, overrideFrom: override, transform };
  },
  height: (a, b) => {
    let override = void 0;
    if (b === 0) {
      b = 1;
      override = { height: "1px" };
    }
    const value = quotientOp(a, b);
    const transform = value == null || isNaN(value) ? void 0 : `scaleY(${value})`;
    return { value, overrideFrom: override, transform };
  }
};
var defaultKeyframeOptions = {
  duration: 333,
  easing: `ease-in-out`
};
var defaultCssProperties = [
  "left",
  "top",
  "width",
  "height",
  "opacity",
  "color",
  "background"
];
var isDirty = (value, previous) => {
  if (Array.isArray(value)) {
    if (Array.isArray(previous) && previous.length === value.length && value.every((v, i) => v === previous[i])) {
      return false;
    }
  } else if (previous === value) {
    return false;
  }
  return true;
};
var nodeToAnimateMap = /* @__PURE__ */ new WeakMap();
var Animate = class extends AsyncDirective {
  constructor(part) {
    super(part);
    this._hostHasUpdated = false;
    this._parentNode = null;
    this._nextSibling = null;
    this._shouldAnimate = true;
    this.shouldLog = false;
    if (part.type === PartType.CHILD) {
      throw new Error("The `animate` directive must be used in attribute position.");
    }
    this.createFinished();
  }
  createFinished() {
    var _a;
    (_a = this.resolveFinished) == null ? void 0 : _a.call(this);
    this.finished = new Promise((r) => {
      this._resolveFinished = r;
    });
  }
  async resolveFinished() {
    var _a;
    (_a = this._resolveFinished) == null ? void 0 : _a.call(this);
    this._resolveFinished = void 0;
  }
  render(_options) {
    return nothing;
  }
  getController() {
    return controllerMap.get(this._host);
  }
  isDisabled() {
    var _a;
    return this.options.disabled || ((_a = this.getController()) == null ? void 0 : _a.disabled);
  }
  update(part, [options]) {
    var _a;
    const firstUpdate = this._host === void 0;
    if (firstUpdate) {
      this._host = (_a = part.options) == null ? void 0 : _a.host;
      this._host.addController(this);
      this._host.updateComplete.then((_) => this._hostHasUpdated = true);
      this.element = part.element;
      nodeToAnimateMap.set(this.element, this);
    }
    this.optionsOrCallback = options;
    if (firstUpdate || typeof options !== "function") {
      this._setOptions(options);
    }
    return this.render(options);
  }
  // TODO(sorvell): instead of a function/object, just use an object that the
  // user can mutate and create accessors for the data that do lookups as needed.
  // We're doing this every hostUpdate anyway and these lookups are fast.
  _setOptions(options) {
    options = options ?? {};
    const controller = this.getController();
    if (controller !== void 0) {
      options = {
        ...controller.defaultOptions,
        ...options
      };
      options.keyframeOptions = {
        ...controller.defaultOptions.keyframeOptions,
        ...options.keyframeOptions
      };
    }
    options.properties ?? (options.properties = defaultCssProperties);
    this.options = options;
  }
  // Measures and returns metrics for the element's bounding box and styling
  _measure() {
    const props = {};
    const bounds = this.element.getBoundingClientRect();
    const computedStyle = getComputedStyle(this.element);
    this.options.properties.forEach((p) => {
      const v = bounds[p] ?? (!transformProps[p] ? computedStyle[p] : void 0);
      const asNum = Number(v);
      props[p] = isNaN(asNum) ? String(v) : asNum;
    });
    return props;
  }
  // Returns true if a `animate` should be started.
  _canStart() {
    let dirty = true, value = void 0;
    if (this.options.guard) {
      value = this.options.guard();
      dirty = isDirty(value, this._previousValue);
    }
    this._shouldAnimate = this._hostHasUpdated && !this.isDisabled() && !this.isAnimating() && dirty && this.element.isConnected;
    if (this._shouldAnimate) {
      this._previousValue = Array.isArray(value) ? Array.from(value) : value;
    }
    return this._shouldAnimate;
  }
  hostUpdate() {
    if (typeof this.optionsOrCallback === "function") {
      this._setOptions(this.optionsOrCallback());
    }
    if (this._canStart()) {
      this._fromValues = this._measure();
      this._parentNode = this._parentNode ?? this.element.parentNode;
      this._nextSibling = this.element.nextSibling;
    }
  }
  async hostUpdated() {
    if (!this._shouldAnimate || !this.element.isConnected || this.options.skipInitial && !this.isHostRendered) {
      return;
    }
    this.prepare();
    await animationFrame;
    let frames;
    const ancestors = this._getAncestors();
    const animationOptions = this._calculateKeyframeOptions(this.options.keyframeOptions, ancestors);
    const toValues = this._measure();
    if (this._fromValues !== void 0) {
      const { from, to } = this._applyAncestorAdjustments(this._fromValues, toValues, ancestors);
      this.log("measured", [this._fromValues, toValues, from, to]);
      frames = this.calculateKeyframes(from, to);
    } else {
      const disconnected = disconnectedProps.get(this.options.inId);
      if (disconnected) {
        disconnectedProps.delete(this.options.inId);
        const { from, to } = this._applyAncestorAdjustments(disconnected, toValues, ancestors);
        frames = this.calculateKeyframes(from, to);
        frames = this.options.in ? [
          { ...this.options.in[0], ...frames[0] },
          ...this.options.in.slice(1),
          frames[1]
        ] : frames;
        z++;
        frames.forEach((f) => f["zIndex"] = z);
      } else if (this.options.in) {
        frames = [...this.options.in, {}];
      }
    }
    noAwait(this.animate(frames, animationOptions));
  }
  resetStyles() {
    if (this._styles !== void 0) {
      this.element.setAttribute("style", this._styles ?? "");
      this._styles = void 0;
    }
  }
  commitStyles() {
    var _a, _b;
    this._styles = this.element.getAttribute("style");
    (_a = this.webAnimation) == null ? void 0 : _a.commitStyles();
    (_b = this.webAnimation) == null ? void 0 : _b.cancel();
  }
  reconnected() {
  }
  // Experimental animate out functionality.
  async disconnected() {
    var _a;
    if (!this._shouldAnimate) {
      return;
    }
    if (this.options.id !== void 0) {
      disconnectedProps.set(this.options.id, this._fromValues);
    }
    if (this.options.out === void 0) {
      return;
    }
    this.prepare();
    await animationFrame();
    if ((_a = this._parentNode) == null ? void 0 : _a.isConnected) {
      const ref = this._nextSibling && this._nextSibling.parentNode === this._parentNode ? this._nextSibling : null;
      this._parentNode.insertBefore(this.element, ref);
      if (this.options.stabilizeOut) {
        const shifted = this._measure();
        this.log("stabilizing out");
        const left = this._fromValues["left"] - shifted["left"];
        const top = this._fromValues["top"] - shifted["top"];
        const isStatic = getComputedStyle(this.element).position === "static";
        if (isStatic && (left !== 0 || top !== 0)) {
          this.element.style.position = "relative";
        }
        if (left !== 0) {
          this.element.style.left = left + "px";
        }
        if (top !== 0) {
          this.element.style.top = top + "px";
        }
      }
    }
    const keyframeOptions = this._calculateKeyframeOptions(this.options.keyframeOptions);
    await this.animate(this.options.out, keyframeOptions);
    this.element.remove();
  }
  prepare() {
    this.createFinished();
  }
  start() {
    var _a, _b;
    (_b = (_a = this.options).onStart) == null ? void 0 : _b.call(_a, this);
  }
  didFinish(didAnimate) {
    var _a, _b;
    if (didAnimate) {
      (_b = (_a = this.options).onComplete) == null ? void 0 : _b.call(_a, this);
    }
    this._fromValues = void 0;
    this.animatingProperties = void 0;
    this.frames = void 0;
    this.resolveFinished();
  }
  _getAncestors() {
    const ancestors = [];
    for (let p = this.element.parentNode; p; p = p == null ? void 0 : p.parentNode) {
      const a = nodeToAnimateMap.get(p);
      if (a && !a.isDisabled() && a) {
        ancestors.push(a);
      }
    }
    return ancestors;
  }
  get isHostRendered() {
    const hostRendered = renderedHosts.has(this._host);
    if (!hostRendered) {
      this._host.updateComplete.then(() => {
        renderedHosts.add(this._host);
      });
    }
    return hostRendered;
  }
  _calculateKeyframeOptions(options, ancestors = this._getAncestors()) {
    const keyframeOptions = { ...defaultKeyframeOptions };
    ancestors.forEach((a) => Object.assign(keyframeOptions, a.options.keyframeOptions));
    Object.assign(keyframeOptions, options);
    return keyframeOptions;
  }
  // Adjust position based on ancestor scaling.
  _applyAncestorAdjustments(from, to, ancestors) {
    from = { ...from };
    to = { ...to };
    const ancestorProps = ancestors.map((a) => a.animatingProperties).filter((a) => a !== void 0);
    let dScaleX = 1;
    let dScaleY = 1;
    if (ancestorProps.length > 0) {
      ancestorProps.forEach((a) => {
        if (a["width"]) {
          dScaleX = dScaleX / a["width"];
        }
        if (a["height"]) {
          dScaleY = dScaleY / a["height"];
        }
      });
      if (from["left"] !== void 0 && to["left"] !== void 0) {
        from["left"] = dScaleX * from["left"];
        to["left"] = dScaleX * to["left"];
      }
      if (from["top"] !== void 0 && to["top"] !== void 0) {
        from["top"] = dScaleY * from["top"];
        to["top"] = dScaleY * to["top"];
      }
    }
    return { from, to };
  }
  calculateKeyframes(from, to, center = false) {
    const fromFrame = {};
    const toFrame = {};
    let hasFrames = false;
    const props = {};
    for (const p in to) {
      const f = from[p], t = to[p];
      if (p in transformProps) {
        const tp = transformProps[p];
        if (f === void 0 || t === void 0) {
          continue;
        }
        const op = tp(f, t);
        if (op.transform !== void 0) {
          props[p] = op.value;
          hasFrames = true;
          fromFrame["transform"] = `${fromFrame["transform"] ?? ""} ${op["transform"]}`;
          if (op.overrideFrom !== void 0) {
            Object.assign(fromFrame, op.overrideFrom);
          }
        }
      } else if (f !== t && f !== void 0 && t !== void 0) {
        hasFrames = true;
        fromFrame[p] = f;
        toFrame[p] = t;
      }
    }
    fromFrame["transformOrigin"] = toFrame["transformOrigin"] = center ? "center center" : "top left";
    this.animatingProperties = props;
    return hasFrames ? [fromFrame, toFrame] : void 0;
  }
  async animate(frames, options = this.options.keyframeOptions) {
    this.start();
    this.frames = frames;
    let didAnimate = false;
    if (!this.isAnimating() && !this.isDisabled()) {
      if (this.options.onFrames) {
        this.frames = frames = this.options.onFrames(this);
        this.log("modified frames", frames);
      }
      if (frames !== void 0) {
        this.log("animate", [frames, options]);
        didAnimate = true;
        this.webAnimation = this.element.animate(frames, options);
        const controller = this.getController();
        noAwait(controller == null ? void 0 : controller.add(this));
        try {
          await this.webAnimation.finished;
        } catch (e) {
        }
        controller == null ? void 0 : controller.remove(this);
      }
    }
    this.didFinish(didAnimate);
    return didAnimate;
  }
  isAnimating() {
    var _a, _b;
    return ((_a = this.webAnimation) == null ? void 0 : _a.playState) === "running" || ((_b = this.webAnimation) == null ? void 0 : _b.pending);
  }
  log(message, data) {
    if (this.shouldLog && !this.isDisabled()) {
      console.log(message, this.options.id, data);
    }
  }
};
function noAwait(_p) {
}
var animate = directive(Animate);

// node_modules/@lit-labs/motion/development/position.js
var positionedPoints = ["top", "right", "bottom", "left"];
var Position = class extends AsyncDirective {
  constructor(part) {
    super(part);
    if (part.type !== PartType.ELEMENT) {
      throw new Error("The `position` directive must be used in attribute position.");
    }
  }
  render(_targetCallbackOrRef, _positions) {
    return nothing;
  }
  update(part, [target, positions]) {
    var _a;
    if (this._host === void 0) {
      this._host = (_a = part.options) == null ? void 0 : _a.host;
      this._host.addController(this);
    }
    this._element = part.element;
    this._targetCallbackOrRef = target;
    this._positions = positions ?? ["left", "top", "width", "height"];
    return this.render(target, positions);
  }
  hostUpdated() {
    this._position();
  }
  _position() {
    var _a, _b;
    const target = typeof this._targetCallbackOrRef === "function" ? this._targetCallbackOrRef() : (_a = this._targetCallbackOrRef) == null ? void 0 : _a.value;
    const parent = target.offsetParent;
    if (target === void 0 || !parent) {
      return;
    }
    const tr = target.getBoundingClientRect();
    const pr = parent.getBoundingClientRect();
    (_b = this._positions) == null ? void 0 : _b.forEach((p) => {
      const x = positionedPoints.includes(p) ? tr[p] - pr[p] : tr[p];
      this._element.style[p] = `${x}px`;
    });
  }
};
var position = directive(Position);
export {
  Animate,
  AnimateController,
  Position,
  animate,
  animationFrame,
  controllerMap,
  defaultCssProperties,
  defaultKeyframeOptions,
  fade,
  fadeIn,
  fadeInSlow,
  fadeOut,
  flyAbove,
  flyBelow,
  flyLeft,
  flyRight,
  none,
  position,
  transformProps
};
/*! Bundled license information:

lit-html/development/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/motion/development/index.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@lit-labs_motion.js.map
