{
  "version": 3,
  "sources": ["../../lit-html/src/async-directive.ts", "../../@lit-labs/motion/src/animate-controller.ts", "../../@lit-labs/motion/src/animate.ts", "../../@lit-labs/motion/src/position.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._$parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._$parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport * from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean,\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false,\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0,\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined,\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true,\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {ReactiveControllerHost} from 'lit';\nimport {Animate, Options} from './animate.js';\n\nexport const controllerMap = new WeakMap<\n  ReactiveControllerHost,\n  AnimateController\n>();\n\n/**\n * AnimateController can be used to provide default configuration options to all\n * `animate()` directives in a given component.\n *\n * It also provides control over all the `animate()` animations within a given\n * component, for example, `this.animateController.pause()` pauses all animations.\n */\nexport class AnimateController {\n  host: ReactiveControllerHost;\n  defaultOptions: Options;\n  startPaused = false;\n  disabled = false;\n  onComplete?: () => void;\n\n  constructor(\n    host: ReactiveControllerHost,\n    options: {\n      defaultOptions?: Options;\n      startPaused?: boolean;\n      disabled?: boolean;\n      onComplete?: () => void;\n    }\n  ) {\n    this.host = host;\n    this.defaultOptions = options.defaultOptions || {};\n    this.startPaused = !!options.startPaused;\n    this.disabled = !!options.disabled;\n    this.onComplete = options.onComplete;\n    controllerMap.set(this.host, this);\n  }\n\n  /**\n   * Set of active `animate()` directives in the host component\n   */\n  clients = new Set<Animate>();\n\n  protected pendingComplete = false;\n\n  async add(animate: Animate) {\n    this.clients.add(animate);\n    if (this.startPaused) {\n      animate.webAnimation?.pause();\n    }\n    this.pendingComplete = true;\n    await animate.finished;\n    if (this.pendingComplete && !this.isAnimating) {\n      this.pendingComplete = false;\n      this.onComplete?.();\n    }\n  }\n\n  remove(animate: Animate) {\n    this.clients.delete(animate);\n  }\n\n  /**\n   * Pauses all animations running in the host component.\n   */\n  pause() {\n    this.clients.forEach((f) => f.webAnimation?.pause());\n  }\n\n  /**\n   * Plays all active animations in the host component.\n   */\n  play() {\n    this.clients.forEach((f) => f.webAnimation?.play());\n  }\n\n  cancel() {\n    this.clients.forEach((f) => f.webAnimation?.cancel());\n    this.clients.clear();\n  }\n\n  finish() {\n    this.clients.forEach((f) => f.webAnimation?.finish());\n    this.clients.clear();\n  }\n\n  /**\n   * Toggles the play/pause state of all active `animate()` animations in the host component.\n   */\n  togglePlay() {\n    if (this.isPlaying) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n\n  /**\n   * Returns true if the host component has any active `animate()` animations.\n   */\n  get isAnimating() {\n    return this.clients.size > 0;\n  }\n\n  /**\n   * Returns true if the host component has any playing `animate()` animations.\n   */\n  get isPlaying() {\n    return Array.from(this.clients).some(\n      (a) => a.webAnimation?.playState === 'running'\n    );\n  }\n\n  async finished() {\n    await Promise.all(Array.from(this.clients).map((f) => f.finished));\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {ReactiveControllerHost} from 'lit';\nimport {nothing, AttributePart} from 'lit/html.js';\nimport {directive, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {controllerMap} from './animate-controller.js';\nexport {AnimateController} from './animate-controller.js';\n\nexport type CSSValues = {\n  [index: string]: string | number;\n};\n\nexport type CSSPropertiesList = string[];\n\n// zIndex for \"in\" animations\nlet z = 0;\n\nconst disconnectedProps = new Map<unknown, CSSValues>();\nconst renderedHosts = new WeakSet<ReactiveControllerHost>();\n\nexport type Options = {\n  // Options used for the animation\n  keyframeOptions?: KeyframeAnimationOptions;\n  // List of css properties to animate\n  properties?: CSSPropertiesList;\n  // if `true`, the `animate` is disabled\n  disabled?: boolean;\n  // Callback run to produce a value which is dirty checked to determine if animation should run.\n  guard?: () => unknown;\n  // Id for this `animate`; used to link to other `animate`s via e.g. `inId`\n  id?: unknown;\n  // Set to the `animate` id to map to when rendering \"in\"\n  inId?: unknown;\n  // Keyframes to use when animating \"in\"\n  in?: Keyframe[];\n  // Keyframes to use when animating \"out\"\n  out?: Keyframe[];\n  // Set to true to match DOM position when animating \"out\"\n  stabilizeOut?: boolean;\n  // Skips animation when initially rendering\n  skipInitial?: boolean;\n  // Callback run when the `animate` animation starts\n  onStart?: (animate: Animate) => void;\n  // Callback run when the animation is complete\n  onComplete?: (animate: Animate) => void;\n  // Callback run to modify frames used to animate\n  onFrames?: (animate: Animate) => Keyframe[] | undefined;\n};\n\nexport const animationFrame = () =>\n  new Promise((resolve) => requestAnimationFrame(resolve));\n\n// Presets for animating \"in\" and \"out\" of the DOM.\nexport const flyBelow = [{transform: 'translateY(100%) scale(0)', opacity: 0}];\nexport const flyAbove = [{transform: 'translateY(-100%) scale(0)', opacity: 0}];\nexport const flyLeft = [{transform: 'translateX(-100%) scale(0)', opacity: 0}];\nexport const flyRight = [{transform: 'translateX(100%) scale(0)', opacity: 0}];\nexport const none = [{}];\nexport const fadeOut = [{opacity: 0}];\nexport const fade = fadeOut;\nexport const fadeIn = [{opacity: 0}, {opacity: 1}];\nexport const fadeInSlow = [\n  {opacity: 0},\n  {opacity: 0.25, offset: 0.75},\n  {opacity: 1},\n];\n\nconst diffOp = (a: number, b: number) => {\n  const v = a - b;\n  return v === 0 ? undefined : v;\n};\nconst quotientOp = (a: number, b: number) => {\n  const v = a / b;\n  return v === 1 ? undefined : v;\n};\n\n// Computes a transform given a before and after input for given properties.\nexport const transformProps: {\n  [p: string]: (\n    a: number,\n    b: number\n  ) => {\n    value?: number;\n    transform?: string;\n    overrideFrom?: {[k: string]: string};\n  };\n} = {\n  left: (a: number, b: number) => {\n    const value = diffOp(a, b);\n    const transform =\n      value == null || isNaN(value) ? undefined : `translateX(${value}px)`;\n    return {value, transform};\n  },\n  top: (a: number, b: number) => {\n    const value = diffOp(a, b);\n    const transform =\n      value == null || isNaN(value) ? undefined : `translateY(${value}px)`;\n    return {value, transform};\n  },\n  width: (a: number, b: number) => {\n    let override: {} | undefined = undefined;\n    // 'To' values of 0 would cause `value` to be Infinity. Instead we override\n    // `b` to be 1 and add 1px as an override of width.\n    if (b === 0) {\n      b = 1;\n      override = {width: '1px'};\n    }\n    const value = quotientOp(a, b);\n    const transform =\n      value == null || isNaN(value) ? undefined : `scaleX(${value})`;\n    return {value, overrideFrom: override, transform};\n  },\n  height: (a: number, b: number) => {\n    let override: {} | undefined = undefined;\n    // 'To' values of 0 would cause `value` to be Infinity. Instead we override\n    // `b` to be 1 and add 1px as an override of height.\n    if (b === 0) {\n      b = 1;\n      override = {height: '1px'};\n    }\n    const value = quotientOp(a, b);\n    const transform =\n      value == null || isNaN(value) ? undefined : `scaleY(${value})`;\n    return {value, overrideFrom: override, transform};\n  },\n};\n\nexport const defaultKeyframeOptions: KeyframeAnimationOptions = {\n  duration: 333,\n  easing: `ease-in-out`,\n};\n\nexport const defaultCssProperties: CSSPropertiesList = [\n  'left',\n  'top',\n  'width',\n  'height',\n  'opacity',\n  'color',\n  'background',\n];\n\n// Dirty checks the value received from the `guard` option.\nconst isDirty = (value: unknown, previous: unknown) => {\n  if (Array.isArray(value)) {\n    // Dirty-check arrays by item\n    if (\n      Array.isArray(previous) &&\n      previous.length === value.length &&\n      value.every((v, i) => v === (previous as Array<unknown>)[i])\n    ) {\n      return false;\n    }\n  } else if (previous === value) {\n    // Dirty-check non-arrays by identity\n    return false;\n  }\n  return true;\n};\n\n// Mapping of node on which the `animate` directive is used to the `animate` directive.\n// Used to get the ancestor `animate` animations (which are used to modify\n// `animate` transforms), done by ascending the DOM.\nconst nodeToAnimateMap = new WeakMap<Node, Animate>();\n\n/**\n * `animate` directive class. Animates a node's position between renders.\n */\nexport class Animate extends AsyncDirective {\n  private _hostHasUpdated = false;\n  private _host?: ReactiveControllerHost;\n  private _fromValues?: CSSValues;\n  private _parentNode: Element | null = null;\n  private _nextSibling: Node | null = null;\n  private _shouldAnimate = true;\n  private _previousValue: unknown;\n  private _styles?: string | undefined | null;\n  element!: HTMLElement;\n\n  shouldLog = false;\n  animatingProperties?: CSSValues;\n  frames?: Keyframe[];\n  webAnimation?: Animation;\n  options!: Options;\n  optionsOrCallback?: (() => Options) | Options;\n\n  finished!: Promise<void>;\n  private _resolveFinished?: () => void;\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type === PartType.CHILD) {\n      throw new Error(\n        'The `animate` directive must be used in attribute position.'\n      );\n    }\n    this.createFinished();\n  }\n\n  createFinished() {\n    this.resolveFinished?.();\n    this.finished = new Promise((r) => {\n      this._resolveFinished = r;\n    });\n  }\n\n  async resolveFinished() {\n    this._resolveFinished?.();\n    this._resolveFinished = undefined;\n  }\n\n  render(_options?: (() => Options) | Options) {\n    return nothing;\n  }\n\n  getController() {\n    return controllerMap.get(this._host!);\n  }\n\n  isDisabled() {\n    return this.options.disabled || this.getController()?.disabled;\n  }\n\n  override update(part: AttributePart, [options]: Parameters<this['render']>) {\n    const firstUpdate = this._host === undefined;\n    if (firstUpdate) {\n      this._host = part.options?.host as ReactiveControllerHost;\n      this._host.addController(this);\n      this._host.updateComplete.then((_) => (this._hostHasUpdated = true));\n      this.element = part.element;\n      nodeToAnimateMap.set(this.element, this);\n    }\n    this.optionsOrCallback = options;\n    if (firstUpdate || typeof options !== 'function') {\n      this._setOptions(options as Options);\n    }\n    return this.render(options);\n  }\n\n  // TODO(sorvell): instead of a function/object, just use an object that the\n  // user can mutate and create accessors for the data that do lookups as needed.\n  // We're doing this every hostUpdate anyway and these lookups are fast.\n  private _setOptions(options?: Options) {\n    options = options ?? {};\n    // Mixin controller options.\n    const controller = this.getController();\n    if (controller !== undefined) {\n      options = {\n        ...controller.defaultOptions,\n        ...options,\n      };\n      options.keyframeOptions = {\n        ...controller.defaultOptions.keyframeOptions,\n        ...options.keyframeOptions,\n      };\n    }\n    // Ensure there are some properties to animation and some animation options.\n    options!.properties ??= defaultCssProperties;\n    this.options = options;\n  }\n\n  // Measures and returns metrics for the element's bounding box and styling\n  private _measure() {\n    const props: CSSValues = {};\n    const bounds = this.element.getBoundingClientRect();\n    const computedStyle = getComputedStyle(this.element);\n    this.options.properties!.forEach((p) => {\n      const v =\n        bounds[p as keyof typeof bounds] ??\n        (!transformProps[p as keyof typeof transformProps]\n          ? computedStyle[p as keyof CSSStyleDeclaration]\n          : undefined);\n      const asNum = Number(v);\n      props[p] = isNaN(asNum) ? String(v) : asNum;\n    });\n    return props;\n  }\n\n  // Returns true if a `animate` should be started.\n  private _canStart() {\n    let dirty = true,\n      value = undefined;\n    if (this.options.guard) {\n      value = this.options.guard();\n      dirty = isDirty(value, this._previousValue);\n    }\n    this._shouldAnimate =\n      this._hostHasUpdated &&\n      !this.isDisabled() &&\n      !this.isAnimating() &&\n      dirty &&\n      this.element.isConnected;\n    if (this._shouldAnimate) {\n      // Copy the value if it's an array so that if it's mutated we don't forget\n      // what the previous values were.\n      this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n    }\n    return this._shouldAnimate;\n  }\n\n  hostUpdate() {\n    // TODO(sorvell): If options will change that will affect measuring,\n    // then the user must pass a callback which can be called at update time.\n    if (typeof this.optionsOrCallback === 'function') {\n      this._setOptions(this.optionsOrCallback());\n    }\n    if (this._canStart()) {\n      this._fromValues = this._measure();\n      // Record parent and nextSibling used to re-attach node when animating \"out\"\n      this._parentNode =\n        this._parentNode ?? (this.element.parentNode as Element);\n      this._nextSibling = this.element.nextSibling;\n    }\n  }\n\n  async hostUpdated() {\n    if (\n      !this._shouldAnimate ||\n      !this.element.isConnected ||\n      (this.options.skipInitial && !this.isHostRendered)\n    ) {\n      return;\n    }\n    this.prepare();\n    // Wait for rendering so any sub-elements have a chance to render.\n    await animationFrame;\n    let frames: Keyframe[] | undefined;\n    const ancestors = this._getAncestors();\n    // These inherit from ancestors. This allows easier synchronization of\n    // child `animate`s within ancestor `animate`s.\n    const animationOptions = this._calculateKeyframeOptions(\n      this.options.keyframeOptions,\n      ancestors\n    );\n    const toValues = this._measure();\n    // Normal or inverse scale\n    if (this._fromValues !== undefined) {\n      const {from, to} = this._applyAncestorAdjustments(\n        this._fromValues,\n        toValues,\n        ancestors\n      );\n      this.log('measured', [this._fromValues, toValues, from, to]);\n      frames = this.calculateKeyframes(from, to);\n      // \"In\" `animate`.\n    } else {\n      const disconnected = disconnectedProps.get(this.options.inId);\n      if (disconnected) {\n        // use disconnected data only once.\n        disconnectedProps.delete(this.options.inId);\n        const {from, to} = this._applyAncestorAdjustments(\n          disconnected!,\n          toValues,\n          ancestors\n        );\n        frames = this.calculateKeyframes(from, to);\n        // \"merge\" with \"in\" frames\n        frames = this.options.in\n          ? [\n              {...this.options.in[0], ...frames![0]},\n              ...this.options.in.slice(1),\n              frames![1],\n            ]\n          : frames;\n        // adjust z so always on top...\n        z++;\n        frames!.forEach((f) => (f['zIndex'] = z));\n      } else if (this.options.in) {\n        frames = [...this.options.in, {}];\n      }\n    }\n    noAwait(this.animate(frames, animationOptions));\n  }\n\n  resetStyles() {\n    if (this._styles !== undefined) {\n      this.element.setAttribute('style', this._styles ?? '');\n      this._styles = undefined;\n    }\n  }\n\n  commitStyles() {\n    this._styles = this.element.getAttribute('style');\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.webAnimation as any)?.commitStyles();\n    this.webAnimation?.cancel();\n  }\n\n  override reconnected() {}\n\n  // Experimental animate out functionality.\n  override async disconnected() {\n    if (!this._shouldAnimate) {\n      return;\n    }\n    if (this.options.id !== undefined) {\n      disconnectedProps.set(this.options.id, this._fromValues!);\n    }\n    if (this.options.out === undefined) {\n      return;\n    }\n    this.prepare();\n    await animationFrame();\n    if (this._parentNode?.isConnected) {\n      // put element back in DOM\n      const ref =\n        this._nextSibling && this._nextSibling.parentNode === this._parentNode\n          ? this._nextSibling\n          : null;\n      this._parentNode.insertBefore(this.element, ref);\n      // Optionally move element back to its position before it was detached.\n      if (this.options.stabilizeOut) {\n        // Measure current position after re-attaching.\n        const shifted = this._measure();\n        this.log('stabilizing out');\n        // TODO(sorvell): these nudges could conflict with existing styling\n        // or animation but setting left/top should be rare, especially via\n        // animation.\n        const left =\n          (this._fromValues!['left'] as number) - (shifted['left'] as number);\n        const top =\n          (this._fromValues!['top'] as number) - (shifted['top'] as number);\n        const isStatic = getComputedStyle(this.element).position === 'static';\n        if (isStatic && (left !== 0 || top !== 0)) {\n          this.element.style.position = 'relative';\n        }\n        if (left !== 0) {\n          this.element.style.left = left + 'px';\n        }\n        if (top !== 0) {\n          this.element.style.top = top + 'px';\n        }\n      }\n    }\n    // These inherit from ancestors. This allows easier synchronization of\n    // child `animate`s within ancestor `animate`s.\n    const keyframeOptions = this._calculateKeyframeOptions(\n      this.options.keyframeOptions\n    );\n    await this.animate(this.options.out, keyframeOptions);\n    this.element.remove();\n  }\n\n  prepare() {\n    this.createFinished();\n  }\n\n  start() {\n    this.options.onStart?.(this);\n  }\n\n  didFinish(didAnimate: boolean) {\n    if (didAnimate) {\n      this.options.onComplete?.(this);\n    }\n    this._fromValues = undefined;\n    this.animatingProperties = undefined;\n    this.frames = undefined;\n    this.resolveFinished();\n  }\n\n  private _getAncestors() {\n    const ancestors = [];\n    for (\n      let p: Node | null | undefined = this.element.parentNode;\n      p;\n      p = p?.parentNode\n    ) {\n      const a = nodeToAnimateMap.get(p!);\n      if (a && !a.isDisabled() && a) {\n        ancestors.push(a);\n      }\n    }\n    return ancestors;\n  }\n\n  protected get isHostRendered() {\n    const hostRendered = renderedHosts.has(this._host!);\n    if (!hostRendered) {\n      this._host!.updateComplete.then(() => {\n        renderedHosts.add(this._host!);\n      });\n    }\n    return hostRendered;\n  }\n\n  private _calculateKeyframeOptions(\n    options: KeyframeAnimationOptions | undefined,\n    ancestors: Animate[] = this._getAncestors()\n  ) {\n    // merges this `animate`'s options over ancestor options over defaults\n    const keyframeOptions = {...defaultKeyframeOptions};\n    ancestors.forEach((a) =>\n      Object.assign(keyframeOptions, a.options.keyframeOptions)\n    );\n    Object.assign(keyframeOptions, options);\n    return keyframeOptions;\n  }\n\n  // Adjust position based on ancestor scaling.\n  private _applyAncestorAdjustments(\n    from: CSSValues,\n    to: CSSValues,\n    ancestors: Animate[]\n  ) {\n    from = {...from};\n    to = {...to};\n    const ancestorProps = ancestors\n      .map((a) => a.animatingProperties)\n      .filter((a) => a !== undefined) as CSSValues[];\n    let dScaleX = 1;\n    let dScaleY = 1;\n    if (ancestorProps.length > 0) {\n      // gather scaling data for ancestors\n      ancestorProps.forEach((a) => {\n        if (a['width']) {\n          dScaleX = dScaleX / (a['width'] as number);\n        }\n        if (a['height']) {\n          dScaleY = dScaleY / (a['height'] as number);\n        }\n      });\n      // Move position by ancestor scaling amount.\n      if (from['left'] !== undefined && to['left'] !== undefined) {\n        from['left'] = dScaleX * (from['left'] as number);\n        to['left'] = dScaleX * (to['left'] as number);\n      }\n      if (from['top'] !== undefined && to['top'] !== undefined) {\n        from['top'] = dScaleY * (from['top'] as number);\n        to['top'] = dScaleY * (to['top'] as number);\n      }\n    }\n    return {from, to};\n  }\n\n  protected calculateKeyframes(from: CSSValues, to: CSSValues, center = false) {\n    const fromFrame: Keyframe = {};\n    const toFrame: Keyframe = {};\n    let hasFrames = false;\n    const props: CSSValues = {};\n    for (const p in to) {\n      const f = from[p],\n        t = to[p];\n      if (p in transformProps) {\n        const tp = transformProps[p as keyof typeof transformProps];\n        if (f === undefined || t === undefined) {\n          continue;\n        }\n        const op = tp(f as number, t as number);\n        if (op.transform !== undefined) {\n          props[p] = op.value!;\n          hasFrames = true;\n          fromFrame['transform'] = `${fromFrame['transform'] ?? ''} ${\n            op['transform']\n          }`;\n          if (op.overrideFrom !== undefined) {\n            Object.assign(fromFrame, op.overrideFrom);\n          }\n        }\n      } else if (f !== t && f !== undefined && t !== undefined) {\n        hasFrames = true;\n        fromFrame[p] = f;\n        toFrame[p] = t;\n      }\n    }\n    fromFrame['transformOrigin'] = toFrame['transformOrigin'] = center\n      ? 'center center'\n      : 'top left';\n    this.animatingProperties = props;\n    return hasFrames ? [fromFrame, toFrame] : undefined;\n  }\n\n  protected async animate(\n    frames: Keyframe[] | undefined,\n    options = this.options.keyframeOptions\n  ) {\n    this.start();\n    this.frames = frames;\n    let didAnimate = false;\n    if (!this.isAnimating() && !this.isDisabled()) {\n      if (this.options.onFrames) {\n        this.frames = frames = this.options.onFrames(this);\n        this.log('modified frames', frames);\n      }\n      if (frames !== undefined) {\n        this.log('animate', [frames, options]);\n        didAnimate = true;\n        this.webAnimation = this.element.animate(frames, options);\n        const controller = this.getController();\n        noAwait(controller?.add(this));\n        try {\n          await this.webAnimation.finished;\n        } catch (e) {\n          // cancelled.\n        }\n        controller?.remove(this);\n      }\n    }\n    this.didFinish(didAnimate);\n    return didAnimate;\n  }\n\n  protected isAnimating() {\n    return (\n      this.webAnimation?.playState === 'running' || this.webAnimation?.pending\n    );\n  }\n\n  log(message: string, data?: unknown) {\n    if (this.shouldLog && !this.isDisabled()) {\n      console.log(message, this.options.id, data);\n    }\n  }\n}\n\n/**\n * Used in an async function to mark a promise that we're deliberately not\n * awaiting.\n */\nfunction noAwait(_p: null | undefined | Promise<unknown>) {}\n\n/**\n * The `animate` directive animates a node's layout between renders.\n * It will perform a \"tweening\" animation between the two states based on\n * the options given. In addition, elements can animate when they initially\n * render to DOM and when they are removed.\n *\n * Options include:\n * * animationOptions:  configure animation via standard KeyframeAnimationOptions\n * * properties: list of properties to animate, defaults to\n * ['left', 'top','width', 'height', 'opacity', 'color', 'background']\n * * disabled: disables animation\n * * guard: function producing values that must change for the `animate` to run\n * * in: keyframes to use when animating in\n * * out: keyframes to use when animating out\n * * skipInitial: skip animating in the first time\n * * id: used to link to other `animate`s via `inId`\n * * inId: id of the `animate` to render from when animating in\n * * onStart: run when the `animate` starts\n * * onComplete: run when the `animate` completes\n * * onFrames: run when the frames are produces, use to modify frames\n */\nexport const animate = directive(Animate);\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {LitElement} from 'lit';\nimport {nothing, AttributePart} from 'lit/html.js';\nimport {directive, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\n\ninterface Positionables {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n}\n\ntype Ref = {value: HTMLElement};\nexport type TargetCallbackOrRef = (() => HTMLElement) | Ref;\n\nexport type Positions = Array<keyof Positionables>;\n\nconst positionedPoints = ['top', 'right', 'bottom', 'left'];\n\nexport class Position extends AsyncDirective {\n  private _host?: LitElement;\n  private _element?: Element;\n  private _targetCallbackOrRef!: TargetCallbackOrRef;\n  private _positions?: Positions;\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.ELEMENT) {\n      throw new Error(\n        'The `position` directive must be used in attribute position.'\n      );\n    }\n  }\n\n  render(_targetCallbackOrRef: TargetCallbackOrRef, _positions: Positions) {\n    return nothing;\n  }\n\n  override update(\n    part: AttributePart,\n    [target, positions]: Parameters<this['render']>\n  ) {\n    if (this._host === undefined) {\n      this._host = part.options?.host as LitElement;\n      this._host.addController(this);\n    }\n    this._element = part.element;\n    this._targetCallbackOrRef = target;\n    this._positions = positions ?? ['left', 'top', 'width', 'height'];\n    return this.render(target, positions);\n  }\n\n  hostUpdated() {\n    this._position();\n  }\n\n  private _position() {\n    const target =\n      typeof this._targetCallbackOrRef === 'function'\n        ? this._targetCallbackOrRef()\n        : this._targetCallbackOrRef?.value;\n    const parent = target.offsetParent;\n    if (target === undefined || !parent) {\n      return;\n    }\n    const tr = target.getBoundingClientRect();\n    const pr = parent.getBoundingClientRect();\n    this._positions?.forEach((p) => {\n      const x = positionedPoints.includes(p) ? tr[p] - pr[p] : tr[p];\n      (this._element as HTMLElement).style[p] = `${x}px`;\n    });\n  }\n}\n\n/**\n * Positions and sizes the element on which the `position()` directive is used\n * relative to the given target element.\n */\nexport const position = directive(Position);\n"],
  "mappings": "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",
  "names": ["animate"]
}
